using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.IO;
using System.Collections;
using NonSucking.Framework.Extension.Generators.Attributes;
using System.Reflection;

namespace NonSucking.Framework.Extension.Generators
{
    /*
     Unsere Attribute:
    1. Ignore
    2. Property name for ctor / Ctor Attribute for property name
    3. PrefferedCtor
    4. Custom Serialize/Deserialize
    
    Future:
    5. BinaryWriter / Span Switch/Off/On
     */


    [Generator]
    public class NoosonGenerator : ISourceGenerator
    {
        private const string writerName = "writer";
        private readonly List<Diagnostic> diagnostics = new();
        private static readonly NoosonAttributeTemplate genSerializationAttribute = new();

        public void Initialize(GeneratorInitializationContext context)
        {
            try
            {
                var templates
                = Assembly
                .GetAssembly(typeof(Template))
                .GetTypes()
                .Where(t => typeof(Template).IsAssignableFrom(t) && !t.IsAbstract && !t.IsInterface)
                .Select(t => (Template)Activator.CreateInstance(t))
                .ToList();


                context.RegisterForPostInitialization(i =>
                {
                    foreach (var template in templates)
                    {
                        i.AddSource(template.Name, template.ToString());
                    }
                });

                context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
            }
            catch (Exception ex)
            {
                Debugger.Break();
                throw;
            }
        }

        public void Execute(GeneratorExecutionContext context)
        {
            try
            {
                InternalExecute(context);
            }
            catch (Exception ex)
            {
                Debugger.Break();
                throw;
            }

        }

        private void InternalExecute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
                return;

            var attributeSymbol
                = context
                    .Compilation
                    .GetTypeByMetadataName(genSerializationAttribute.FullName);

            foreach (var classToAugment in receiver.ClassesToAugment)
            {
                var builder = new StringBuilder();

                GenerateSerializeWithBinaryWriter(context, builder, classToAugment.Properties);

                var rawSourceText
                    = $@"

using System.IO;
namespace {classToAugment.TypeSymbol.ContainingNamespace.ToDisplayString()}
{{
    public partial class {classToAugment.TypeSymbol.Name}
    {{
        {builder}
    }}
}}

                ";

                //rawSourceText += "You need a attribute for property XY, because it's a duplicate";
                var hintName
                    = $"{classToAugment.TypeSymbol.ToDisplayString()}.autogenerated.cs";

                var sourceText = SourceText.From(rawSourceText, Encoding.UTF8);


                /*
                                            Schlachtplan
                1. IEnumerable => Not Supported (yet)
                3. Attributes => Überschreiben von Property Namen zu Ctor Parameter
                4. Custom Type Serializer/Deserializer => Falls etwas not supported wird, wie IReadOnlySet, IEnumerable
                5. Derserialize => Serialize Logik rückwärts aufrufen
                2. Ctor Analyzing => Get Only Props (Simples namematching von Parameter aufgrund von Namen), ReadOnlyProps ohne Ctor Parameter ignorieren
                1. Listen: IEnumerable => List, IReadOnlyCollection => ReadOnlyCollection, IReadOnlyDictionary => ReadOnlyDictionary
                6. Fehler/Warnings ausgeben
                 */

                context.AddSource(hintName, sourceText);

            }

            foreach (var diagnostic in diagnostics)
            {
                context.ReportDiagnostic(diagnostic);
            }
        }

        private void GenerateSerializeWithBinaryWriter(GeneratorExecutionContext context, StringBuilder builder, List<TypeGroupInfo> typePropertiesGroups)
        {
            builder.AppendLine($"public void Serialize(BinaryWriter {writerName})");
            builder.AppendLine("{");
            CreateWriterLinesForProperties(builder, typePropertiesGroups);
            builder.AppendLine("}");
        }

        private void CreateWriterLinesForProperties(StringBuilder builder, List<TypeGroupInfo> typePropertiesGroups)
        {
            foreach (var typePropertiesGroup in typePropertiesGroups)
            {
                var typeSymbol = typePropertiesGroup.TypeSymbol;

                GenerateWriteForProps(builder, typePropertiesGroup);
            }
        }

        private bool GenerateWriteForProps(StringBuilder builder, TypeGroupInfo typePropertiesGroup, string parentName = "this")
        {
            bool success = true;
            var ignore = new NoosonIgnoreAttributeTemplate();

            foreach (var property in typePropertiesGroup.Properties)
            {
                ITypeSymbol propertyType = property.PropertySymbol.Type;

                string propertyName = property.PropertySymbol.Name;
                var index = propertyName.IndexOf('.');

                if (index >= 0)
                    continue;

                if (property.PropertySymbol.GetAttributes().Any(a => a.AttributeClass.ToDisplayString() == ignore.FullName))
                    continue;

                success =
                    TrySerializing(builder, propertyType, writerName, parentName + "." + propertyName);

                if (!success)
                    return success;
            }

            return success;
        }

        //Proudly stolen from https://github.com/mknejp/dotvariant/blob/c59599a079637e38c3471a13b6a0443e4e607058/src/dotVariant.Generator/Diagnose.cs#L234
        private static Diagnostic MakeDiagnostic(string id, string title, string message, Location location, DiagnosticSeverity severity, string helpLinkurl = null, params string[] customTags)
        => Diagnostic.Create(
        new DiagnosticDescriptor(
            $"{nameof(NoosonGenerator)}.{id}",
            title,
            message,
            nameof(NoosonGenerator),
            severity,
            true,
            helpLinkUri: helpLinkurl,
            customTags: customTags),
        location);

        private bool TrySerializing(StringBuilder builder, ITypeSymbol propertyType, string writerName, string propertyName)
            => TrySpecialTypeWriterCall(builder, propertyType, writerName, propertyName)
                || TryEnumWriterCall(builder, propertyType, writerName, propertyName)
                || TrySerializeWriterCall(builder, propertyType, writerName, propertyName)
                || TrySerializeList(builder, propertyType, writerName, propertyName)
                || TrySerializePublicProps(builder, propertyType, writerName, propertyName);

        private bool TrySpecialTypeWriterCall(StringBuilder builder, ITypeSymbol property, string writerName, string memberName)
        {
            switch ((int)property.SpecialType)
            {
                case >= 7 and <= 20:
                    builder.AppendLine($"{writerName}.Write({memberName});");
                    return true;
                default:
                    return false;
            }
        }

        private bool TryEnumWriterCall(StringBuilder builder, ITypeSymbol property, string writerName, string memberName)
        {
            if (property.TypeKind != TypeKind.Enum)
                return false;

            if (property is INamedTypeSymbol typeSymbol)
            {
                builder.AppendLine($"{writerName}.Write(({typeSymbol.EnumUnderlyingType}){memberName});");
                return true;
            }
            else
            {
                return false;
            }

        }


        private bool TrySerializeWriterCall(StringBuilder builder, ITypeSymbol property, string writerName, string memberName)
        {
            var member
                = property
                    .GetMembers("Serialize")
                    .OfType<IMethodSymbol>();

            var shouldBeGenerated = property.GetAttributes().Any(x => x.ToString() == genSerializationAttribute.FullName);

            var isUsable
                = shouldBeGenerated || member
                .Any(m =>
                    m.Parameters.Length == 1
                    && m.Parameters[0].ToDisplayString() == typeof(BinaryWriter).FullName
                );

            if (isUsable)
                builder.AppendLine($"{memberName}.Serialize({writerName});");

            return isUsable;
        }

        private bool TrySerializePublicProps(StringBuilder builder, ITypeSymbol typeNameSymbol, string writerName, string memberName)
        {
            if (typeNameSymbol.TypeKind == TypeKind.Interface)
            {
                var success = true;

                //typeNameSymbol.Name == nameof(IEnumerable);

                foreach (var interfaceType in typeNameSymbol.AllInterfaces)
                {
                    success = PropertieForSingleType(builder, interfaceType, memberName);
                    //diagnostics.Add(MakeDiagnostic(
                    //    "🤷", 
                    //    "Unexpected error during generation", 
                    //    $"Property {memberName} needs a name property, because it is a duplicate", 
                    //    typeNameSymbol.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax().GetLocation(), 
                    //    DiagnosticSeverity.Error,
                    //    "https://lmgtfy.app/?q=Property+c%23&iie=1"));

                    if (!success)
                        return success;
                }

                return success;
            }
            else
            {
                return PropertieForSingleType(builder, typeNameSymbol, memberName);
            }
        }

        private bool PropertieForSingleType(StringBuilder builder, ITypeSymbol typeNameSymbol, string memberName)
        {
            var props = typeNameSymbol
                            .GetMembers()
                            .OfType<IPropertySymbol>()
                            .Where(property => property.Name != "this[]");

            return GenerateWriteForProps(builder,
                new TypeGroupInfo(
                    null,
                    new SymbolInfo(),
                    props
                        .Select(x => new PropertyInfo(null, x))
                        .ToArray()
                ),
                memberName
            );
        }

        private bool TrySerializeList(StringBuilder builder, ITypeSymbol propertySymbol, string writerName, string memberName)
        {
            var list = propertySymbol.AllInterfaces.Any(x => x.Name == typeof(IEnumerable).Name);
            if (!list)
                return false;

            var ienumerable = propertySymbol.Name == nameof(IEnumerable);
            if (ienumerable)
            {
                //Diagnostic Error for not supported type
                return true;
            }

            ITypeSymbol genericArgument;
            if (propertySymbol is INamedTypeSymbol nts)
            {
                genericArgument = nts.TypeArguments[0];
            }
            else if (propertySymbol is IArrayTypeSymbol ats)
            {
                genericArgument = ats.ElementType;
            }
            else
                throw new NotSupportedException();

            const string itemName = "item";

            TrySerializePublicProps(builder, propertySymbol, writerName, memberName);
            builder.AppendLine($"foreach (var {itemName} in {memberName})");
            builder.AppendLine("{");

            var props = genericArgument
                .GetMembers()
                .OfType<IPropertySymbol>()
                    .Select(x => new PropertyInfo(null, x))
                    .ToArray();

            if (props.Length > 0)
                GenerateWriteForProps(builder, new TypeGroupInfo(null, default, props), itemName);
            else
                TrySerializing(builder, genericArgument, writerName, itemName);

            builder.AppendLine("}");
            return true;
        }

        private class SyntaxReceiver : ISyntaxContextReceiver
        {
            public List<IFieldSymbol> Fields { get; } = new List<IFieldSymbol>();

            public List<VisitInfo> ClassesToAugment { get; } = new List<VisitInfo>();

            /// <summary>
            /// Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation
            /// </summary>
            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                // any field with at least one attribute is a candidate for property generation
                if (context.Node is ClassDeclarationSyntax classDeclarationSyntax
                    && classDeclarationSyntax.AttributeLists.Count > 0)
                {
                    //classDeclarationSyntax.AttributeLists.FirstOrDefault(a => a.Attributes.FirstOrDefault(at => at.));

                    var typeSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax);
                    var attributes = typeSymbol.GetAttributes();
                    var attribute = attributes.FirstOrDefault(d => d?.AttributeClass.ToDisplayString() == genSerializationAttribute.FullName);

                    if (attribute == default)
                        return;

                    var properties
                        = classDeclarationSyntax
                            .Members
                            .OfType<PropertyDeclarationSyntax>()
                            .OrderBy(x => x.Type.ToString())
                            .GroupBy(x => x.Type)
                            .Select(
                                group =>
                                {
                                    var propertyInfos
                                    = group
                                    .Select(p => new PropertyInfo(p, context.SemanticModel.GetDeclaredSymbol(p)))
                                    .ToArray();

                                    return new TypeGroupInfo(group.Key, context.SemanticModel.GetSymbolInfo(group.Key), propertyInfos);

                                })
                            .ToList();

                    ClassesToAugment.Add(new VisitInfo(classDeclarationSyntax, typeSymbol, attribute, properties));
                }
            }
        }
    }

    internal struct VisitInfo : IEquatable<VisitInfo>
    {
        public ClassDeclarationSyntax ClassDeclaration { get; private set; }
        public INamedTypeSymbol TypeSymbol { get; private set; }
        public AttributeData Attribute { get; private set; }

        public List<TypeGroupInfo> Properties { get; }

        public VisitInfo(ClassDeclarationSyntax classDeclaration, INamedTypeSymbol typeSymbol, AttributeData attribute, List<TypeGroupInfo> properties)
        {
            ClassDeclaration = classDeclaration;
            TypeSymbol = typeSymbol;
            Attribute = attribute;
            Properties = properties;
        }

        public override bool Equals(object obj) => obj is VisitInfo info && Equals(info);
        public bool Equals(VisitInfo other) => EqualityComparer<ClassDeclarationSyntax>.Default.Equals(ClassDeclaration, other.ClassDeclaration) && EqualityComparer<INamedTypeSymbol>.Default.Equals(TypeSymbol, other.TypeSymbol) && EqualityComparer<AttributeData>.Default.Equals(Attribute, other.Attribute) && EqualityComparer<List<TypeGroupInfo>>.Default.Equals(Properties, other.Properties);

        public override int GetHashCode()
        {
            var hashCode = -1923588403;
            hashCode = hashCode * -1521134295 + EqualityComparer<ClassDeclarationSyntax>.Default.GetHashCode(ClassDeclaration);
            hashCode = hashCode * -1521134295 + EqualityComparer<INamedTypeSymbol>.Default.GetHashCode(TypeSymbol);
            hashCode = hashCode * -1521134295 + EqualityComparer<AttributeData>.Default.GetHashCode(Attribute);
            hashCode = hashCode * -1521134295 + EqualityComparer<List<TypeGroupInfo>>.Default.GetHashCode(Properties);
            return hashCode;
        }

        public static bool operator ==(VisitInfo left, VisitInfo right) => left.Equals(right);
        public static bool operator !=(VisitInfo left, VisitInfo right) => !(left == right);
    }

    internal struct TypeGroupInfo : IEquatable<TypeGroupInfo>
    {
        public TypeGroupInfo(TypeSyntax typeSyntax, SymbolInfo typeSymbol, PropertyInfo[] properties)
        {
            TypeSyntax = typeSyntax;
            TypeSymbol = typeSymbol;
            Properties = properties;
        }

        public TypeSyntax TypeSyntax { get; set; }
        public SymbolInfo TypeSymbol { get; set; }
        public PropertyInfo[] Properties { get; private set; }

        public override bool Equals(object obj) => obj is TypeGroupInfo info && Equals(info);
        public bool Equals(TypeGroupInfo other) => EqualityComparer<TypeSyntax>.Default.Equals(TypeSyntax, other.TypeSyntax) && TypeSymbol.Equals(other.TypeSymbol) && EqualityComparer<PropertyInfo[]>.Default.Equals(Properties, other.Properties);

        public override int GetHashCode()
        {
            var hashCode = -1055744729;
            hashCode = hashCode * -1521134295 + EqualityComparer<TypeSyntax>.Default.GetHashCode(TypeSyntax);
            hashCode = hashCode * -1521134295 + TypeSymbol.GetHashCode();
            hashCode = hashCode * -1521134295 + EqualityComparer<PropertyInfo[]>.Default.GetHashCode(Properties);
            return hashCode;
        }

        public static bool operator ==(TypeGroupInfo left, TypeGroupInfo right) => left.Equals(right);
        public static bool operator !=(TypeGroupInfo left, TypeGroupInfo right) => !(left == right);
    }

    internal struct PropertyInfo : IEquatable<PropertyInfo>
    {
        public PropertyInfo(PropertyDeclarationSyntax propertyDeclarationSyntax, IPropertySymbol propertySymbol)
        {
            PropertyDeclarationSyntax = propertyDeclarationSyntax;
            PropertySymbol = propertySymbol;
        }

        public PropertyDeclarationSyntax PropertyDeclarationSyntax { get; set; }
        public IPropertySymbol PropertySymbol { get; set; }

        public override bool Equals(object obj) => obj is PropertyInfo info && Equals(info);
        public bool Equals(PropertyInfo other) => EqualityComparer<PropertyDeclarationSyntax>.Default.Equals(PropertyDeclarationSyntax, other.PropertyDeclarationSyntax) && EqualityComparer<IPropertySymbol>.Default.Equals(PropertySymbol, other.PropertySymbol);

        public override int GetHashCode()
        {
            var hashCode = 819844184;
            hashCode = hashCode * -1521134295 + EqualityComparer<PropertyDeclarationSyntax>.Default.GetHashCode(PropertyDeclarationSyntax);
            hashCode = hashCode * -1521134295 + EqualityComparer<IPropertySymbol>.Default.GetHashCode(PropertySymbol);
            return hashCode;
        }

        public static bool operator ==(PropertyInfo left, PropertyInfo right) => left.Equals(right);
        public static bool operator !=(PropertyInfo left, PropertyInfo right) => !(left == right);
    }
}
