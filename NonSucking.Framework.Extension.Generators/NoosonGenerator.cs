using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using NonSucking.Framework.Extension.Generators.Attributes;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using static NonSucking.Framework.Extension.Generators.CodeBuilder;

namespace NonSucking.Framework.Extension.Generators
{
    /*
     Unsere Attribute:
    1. Ignore
    2. Property name for ctor / Ctor Attribute for property name
    3. PrefferedCtor
    4. Custom Serialize/Deserialize
    
    Future:
    5. BinaryWriter / Span Switch/Off/On
     */


    [Generator]
    public class NoosonGenerator : ISourceGenerator
    {
        private const string writerName = "writer";
        private const string readerName = "reader";
        private readonly List<Diagnostic> diagnostics = new();
        private static readonly NoosonAttributeTemplate genSerializationAttribute = new();

        public NoosonGenerator()
        {

        }

        public void Initialize(GeneratorInitializationContext context)
        {
            try
            {
                List<Template> templates
                = Assembly
                .GetAssembly(typeof(Template))
                .GetTypes()
                .Where(t => typeof(Template).IsAssignableFrom(t) && !t.IsAbstract && !t.IsInterface)
                .Select(t => (Template)Activator.CreateInstance(t))
                .ToList();


                context.RegisterForPostInitialization(i =>
                {
                    foreach (Template template in templates)
                    {
                        i.AddSource(template.Name, template.ToString());
                    }
                });

                context.RegisterForSyntaxNotifications(() => new SyntaxReceiver(genSerializationAttribute));
            }
            catch (Exception)
            {
                Debugger.Break();
                throw;
            }
        }

        public void Execute(GeneratorExecutionContext context)
        {
            try
            {
                InternalExecute(context);
            }
            catch (Exception)
            {
                Debugger.Break();
                throw;
            }

        }

        private void InternalExecute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
            {
                return;
            }

            INamedTypeSymbol attributeSymbol
                = context
                    .Compilation
                    .GetTypeByMetadataName(genSerializationAttribute.FullName);

            foreach (VisitInfo classToAugment in receiver.ClassesToAugment)
            {
                StringBuilder builder = new StringBuilder();
                CodeBuilder codeBuilder = new CodeBuilder(context, classToAugment.Properties);
                GenerateSerializeAndDeserializeMethods(codeBuilder, classToAugment.TypeSymbol.Name);

                string rawSourceText
                    = $@"

using System.IO;
namespace {classToAugment.TypeSymbol.ContainingNamespace.ToDisplayString()}
{{
    public partial class {classToAugment.TypeSymbol.Name}
    {{
        {codeBuilder}
    }}
}}

                ";

                //rawSourceText += "You need a attribute for property XY, because it's a duplicate";
                string hintName
                    = $"{classToAugment.TypeSymbol.ToDisplayString()}.autogenerated.cs";

                SourceText sourceText = SourceText.From(rawSourceText, Encoding.UTF8);


                /*
                                            Schlachtplan
                0. IEnumerable => Not Supported (yet)
                5. Derserialize => Serialize Logik rückwärts aufrufen
                2. Ctor Analyzing => Get Only Props (Simples namematching von Parameter aufgrund von Namen), ReadOnlyProps ohne Ctor Parameter ignorieren
                3. Attributes => Überschreiben von Property Namen zu Ctor Parameter
                4. Custom Type Serializer/Deserializer => Falls etwas not supported wird, wie IReadOnlySet, IEnumerable
                1. Listen: IEnumerable => List, IReadOnlyCollection => ReadOnlyCollection, IReadOnlyDictionary => ReadOnlyDictionary
                6. Fehler/Warnings ausgeben
                7. CleanUp and Refactor
                 */

                context.AddSource(hintName, sourceText);

            }

            foreach (Diagnostic diagnostic in diagnostics)
            {
                context.ReportDiagnostic(diagnostic);
            }
        }

        private void GenerateSerializeAndDeserializeMethods(CodeBuilder codeBuilder, string typeName)
        {
            codeBuilder
                .GetMethodBuilder(GenerationLogic.Serialize, "public", "void", "Serialize", parameters: ("BinaryWriter", writerName))
                .Open()
                    .CreateLinesForProperties(GenerateLineForProps)
                .Close()
                .GetMethodBuilder(GenerationLogic.Deserialize, "public", typeName, "Deserialize", isStatic: true, parameters: ("BinaryReader", readerName))
                .Open()
                    .CreateLinesForProperties(GenerateLineForProps)
                .Close();
        }




        private static bool GenerateLineForProps(MethodBuilder builder, TypeGroupInfo typeGroupInfo, string parentName = null)
        {
            bool success = true;
            NoosonIgnoreAttributeTemplate ignore = new NoosonIgnoreAttributeTemplate();

            foreach (PropertyInfo property in typeGroupInfo.Properties)
            {
                ITypeSymbol propertyType = property.PropertySymbol.Type;

                string propertyName = property.PropertySymbol.Name;
                int index = propertyName.IndexOf('.');


                if (index >= 0)
                {
                    continue;
                }

                if (property.PropertySymbol.GetAttributes().Any(a => a.AttributeClass.ToDisplayString() == ignore.FullName))
                {
                    continue;
                }

                InstanceCallBuilder propertyBuilder = builder.GetProperty(property, parentName is null ? propertyName : parentName + "." + propertyName);

                success = builder.Logic switch
                {
                    GenerationLogic.Serialize => TrySerializing(propertyBuilder, writerName),
                    GenerationLogic.Deserialize => TryDeserializing(propertyBuilder, readerName),
                };

                if (!success)
                {
                    return success;
                }
            }

            return success;
        }



        //Proudly stolen from https://github.com/mknejp/dotvariant/blob/c59599a079637e38c3471a13b6a0443e4e607058/src/dotVariant.Generator/Diagnose.cs#L234
        private static Diagnostic MakeDiagnostic(string id, string title, string message, Location location, DiagnosticSeverity severity, string helpLinkurl = null, params string[] customTags)
        {
            return Diagnostic.Create(
                   new DiagnosticDescriptor(
                       $"{nameof(NoosonGenerator)}.{id}",
                       title,
                       message,
                       nameof(NoosonGenerator),
                       severity,
                       true,
                       helpLinkUri: helpLinkurl,
                       customTags: customTags),
                   location);
        }

        private static bool TrySerializing(InstanceCallBuilder builder, string writerName)
        {
            return TrySpecialTypeWriterCall(builder, writerName)
                           || TryEnumWriterCall(builder, writerName)
                           || TrySerializeWriterCall(builder, writerName)
                           || TrySerializeList(builder, writerName)
                           //|| TryGeneratePublicPropsLines(builder, writerName, true)
                           ;
        }

        private static bool TryDeserializing(InstanceCallBuilder builder, string readerName)
        {
            return TrySpecialTypeReaderCall(builder, readerName)
                           || TryEnumReaderCall(builder, readerName)
                           || TryDeserializeReaderCall(builder, readerName)
                           || TryDeserializeList(builder, readerName)
                           //|| TryGeneratePublicPropsLines(builder, readerName, false)
                           ;
        }

        #region Serialize

        private static bool TrySpecialTypeWriterCall(InstanceCallBuilder builder, string writerName)
        {
            switch ((int)builder.TypeInformation.SpecialType)
            {
                case >= 7 and <= 20:
                    builder.PassPropertyInMethodCall(writerName, "Write");
                    return true;
                default:
                    return false;
            }
        }

        private static bool TryEnumWriterCall(InstanceCallBuilder builder, string writerName)
        {
            if (builder.TypeInformation.TypeKind != TypeKind.Enum)
            {
                return false;
            }

            if (builder.TypeInformation is INamedTypeSymbol typeSymbol)
            {
                builder.PassPropertyInMethodCall(writerName, "Write", castingType: typeSymbol.EnumUnderlyingType.ToString());
                //builder.AppendLine($"{writerName}.Write(({typeSymbol.EnumUnderlyingType}){memberName});");
                return true;
            }
            else
            {
                return false;
            }

        }

        private static bool TrySerializeList(InstanceCallBuilder builder, string writerName)
        {
            bool list = builder.TypeInformation.AllInterfaces.Any(x => x.Name == typeof(IEnumerable).Name);
            if (!list)
            {
                return false;
            }

            bool ienumerable = builder.TypeInformation.Name == nameof(IEnumerable);
            if (ienumerable)
            {
                //Diagnostic Error for not supported type
                return true;
            }

            ITypeSymbol genericArgument;
            if (builder.TypeInformation is INamedTypeSymbol nts)
            {
                genericArgument = nts.TypeArguments[0];
            }
            else if (builder.TypeInformation is IArrayTypeSymbol ats)
            {
                genericArgument = ats.ElementType;
            }
            else
            {
                throw new NotSupportedException();
            }

            const string itemName = "item";

            //TryGeneratePublicPropsLines(builder, writerName, true);
            MethodBuilder mb = builder.AppendToParent();
            LoopBuilder loop = mb
                .ForEach(itemName, builder.InstanceName)
                .Open();


            PropertyInfo[] props = genericArgument
                .GetMembers()
                .OfType<IPropertySymbol>()
                    .Select(x => new PropertyInfo(null, x))
                    .ToArray();

            if (props.Length > 0)
            {
                GenerateLineForProps(mb, new TypeGroupInfo(null, default, props), itemName);
            }
            else //List<string>, List<int>
            {
                InstanceCallBuilder instanceBuilder = mb.GetInstance(genericArgument, itemName);
                TrySerializing(instanceBuilder, writerName);
            }

            loop.Close();
            return true;
        }

        private static bool TrySerializeWriterCall(InstanceCallBuilder builder, string writerName)
        {
            IEnumerable<IMethodSymbol> member
                = builder.TypeInformation
                    .GetMembers("Serialize")
                    .OfType<IMethodSymbol>();

            bool shouldBeGenerated = builder.TypeInformation.GetAttributes().Any(x => x.ToString() == genSerializationAttribute.FullName);

            bool isUsable
                = shouldBeGenerated || member
                .Any(m =>
                    m.Parameters.Length == 1
                    && m.Parameters[0].ToDisplayString() == typeof(BinaryWriter).FullName
                );

            if (isUsable)
            {
                builder.CallMethodOnProperty("Serialize", writerName);
            }

            return isUsable;
        }

        #endregion

        #region Deserialize

        private static bool TrySpecialTypeReaderCall(InstanceCallBuilder builder, string readerName)
        {
            switch ((int)builder.TypeInformation.SpecialType)
            {
                case >= 7 and <= 20:
                    ITypeSymbol property = builder.TypeInformation;
                    string memberName = builder.InstanceName;

                    if (!property.IsReadOnly)
                    {
                        builder
                            .CreateVariable()
                            .AssignVariable();
                    }

                    builder
                        .MethodCall(readerName, GetReadMethodCallFrom(property.SpecialType));
                    return true;
                default:
                    return false;
            }
        }
        private static bool TryEnumReaderCall(InstanceCallBuilder builder, string readerName)
        {
            if (builder.TypeInformation.TypeKind != TypeKind.Enum)
            {
                return false;
            }

            if (builder.TypeInformation is INamedTypeSymbol typeSymbol)
            {
                SpecialType specialType = typeSymbol.EnumUnderlyingType.SpecialType;
                string typeName = typeSymbol.Name;

                if (!builder.TypeInformation.IsReadOnly)
                {
                    builder
                            .CreateVariable()
                            .AssignVariable()
                            .CastToOwnType();
                }

                builder.MethodCall(readerName, GetReadMethodCallFrom(specialType));
                return true;
            }
            else
            {
                return false;
            }

        }

        private static string GetReadMethodCallFrom(SpecialType specialType)
        {
            return specialType switch
            {
                SpecialType.System_Boolean => nameof(BinaryReader.ReadBoolean),
                SpecialType.System_Char => nameof(BinaryReader.ReadChar),
                SpecialType.System_SByte => nameof(BinaryReader.ReadSByte),
                SpecialType.System_Byte => nameof(BinaryReader.ReadByte),
                SpecialType.System_Int16 => nameof(BinaryReader.ReadInt16),
                SpecialType.System_UInt16 => nameof(BinaryReader.ReadUInt16),
                SpecialType.System_Int32 => nameof(BinaryReader.ReadInt32),
                SpecialType.System_UInt32 => nameof(BinaryReader.ReadUInt32),
                SpecialType.System_Int64 => nameof(BinaryReader.ReadInt64),
                SpecialType.System_UInt64 => nameof(BinaryReader.ReadUInt64),
                SpecialType.System_Decimal => nameof(BinaryReader.ReadDecimal),
                SpecialType.System_Single => nameof(BinaryReader.ReadSingle),
                SpecialType.System_Double => nameof(BinaryReader.ReadDouble),
                SpecialType.System_String => nameof(BinaryReader.ReadString),
                _ => throw new NotSupportedException(),
            };
        }

        private static bool TryDeserializeReaderCall(InstanceCallBuilder builder, string readerName)
        {
            IEnumerable<IMethodSymbol> member
                = builder
                    .TypeInformation
                    .GetMembers("Deserialize")
                    .OfType<IMethodSymbol>();

            bool shouldBeGenerated
                = builder
                    .TypeInformation
                    .GetAttributes()
                    .Any(x => x.ToString() == genSerializationAttribute.FullName);

            bool isUsable
                = shouldBeGenerated
                || member
                    .Any(m =>
                        m.Parameters.Length == 1
                        && m.Parameters[0].ToDisplayString() == typeof(BinaryReader).FullName
                        && m.IsStatic
                    );

            if (isUsable)
            {

                if (!builder.TypeInformation.IsReadOnly)
                {
                    builder
                            .CreateVariable()
                            .AssignVariable();
                }

                builder.MethodCall(builder.TypeInformation.Name, "Deserialize", readerName);
            }

            return isUsable;
        }

        private static bool TryDeserializeList(InstanceCallBuilder builder, string writerName)
        {
            bool list = builder.TypeInformation.AllInterfaces.Any(x => x.Name == typeof(IEnumerable).Name);
            if (!list)
            {
                return false;
            }

            bool ienumerable = builder.TypeInformation.Name == nameof(IEnumerable);
            if (ienumerable)
            {
                //Diagnostic Error for not supported type
                return true;
            }

            ITypeSymbol genericArgument;
            if (builder.TypeInformation is INamedTypeSymbol nts)
            {
                genericArgument = nts.TypeArguments[0];
            }
            else if (builder.TypeInformation is IArrayTypeSymbol ats)
            {
                genericArgument = ats.ElementType;
            }
            else
            {
                throw new NotSupportedException();
            }

            const string itemName = "item";

            //TryGeneratePublicPropsLines(builder, writerName, false);
            MethodBuilder mb = builder.AppendToParent();
            LoopBuilder loop = mb
                .For("int i = 0", "i < count", "i++")
                .Open();

            PropertyInfo[] props = genericArgument
                .GetMembers()
                .OfType<IPropertySymbol>()
                    .Select(x => new PropertyInfo(null, x))
                    .ToArray();


            if (props.Length > 0)
            {
                GenerateLineForProps(mb, new TypeGroupInfo(null, default, props), itemName);
            }
            else //List<string>, List<int>
            {
                InstanceCallBuilder instanceBuilder = mb.GetInstance(genericArgument, itemName);
                TryDeserializing(instanceBuilder, writerName);
            }

            loop.Close();
            return true;
        }



        #endregion

        //private static bool TryGeneratePublicPropsLines(InstanceCallBuilder builder, bool serialize)
        //{
        //    if (builder.TypeInformation.TypeKind == TypeKind.Interface)
        //    {
        //        var success = true;
        //        //message.Test = asd;
        //        //message.ABC = 123;


        //        //typeNameSymbol.Name == nameof(IEnumerable);

        //        foreach (var interfaceType in builder.TypeInformation.AllInterfaces)
        //        {

        //            success = PropertiesForSingleType(builder, interfaceType, builder.InstanceName, serialize);
        //            //diagnostics.Add(MakeDiagnostic(
        //            //    "🤷", 
        //            //    "Unexpected error during generation", 
        //            //    $"Property {memberName} needs a name property, because it is a duplicate", 
        //            //    typeNameSymbol.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax().GetLocation(), 
        //            //    DiagnosticSeverity.Error,
        //            //    "https://lmgtfy.app/?q=Property+c%23&iie=1"));

        //            if (!success)
        //                return success;
        //        }

        //        return success;
        //    }
        //    else
        //    {
        //        return PropertiesForSingleType(builder, typeNameSymbol, memberName, serialize);
        //    }
        //}

        //private bool PropertiesForSingleType(InstanceCallBuilder builder, bool serialize)
        //{
        //    var props = builder.TypeInformation
        //                    .GetMembers()
        //                    .OfType<IPropertySymbol>()
        //                    .Where(property => property.Name != "this[]");

        //    return GenerateLineForProps(builder,
        //        new TypeGroupInfo(
        //            null,
        //            new SymbolInfo(),
        //            props
        //                .Select(x => new PropertyInfo(null, x))
        //                .ToArray()
        //        ),
        //        serialize,
        //        builder.InstanceName
        //    );
        //}



    }

    internal static class NoosonExtensions
    {
        internal static MethodBuilder CreateLinesForProperties(this MethodBuilder builder, Func<MethodBuilder, TypeGroupInfo, string, bool> propLineGenerationMethod)
        {
            foreach (TypeGroupInfo typePropertiesGroup in builder.TypeGroupInfos)
            {
                propLineGenerationMethod(builder, typePropertiesGroup, null);
                //GenerateLineForProps(builder, typePropertiesGroup);
            }
            return builder;
        }
    }
}
